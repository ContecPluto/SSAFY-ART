{"remainingRequest":"/Users/kimjunho/front/ssafyart_front/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/kimjunho/front/ssafyart_front/src/components/components/Paintable.vue?vue&type=style&index=0&id=731ff922&scoped=true&lang=css&","dependencies":[{"path":"/Users/kimjunho/front/ssafyart_front/src/components/components/Paintable.vue","mtime":1587609111344},{"path":"/Users/kimjunho/front/ssafyart_front/node_modules/css-loader/dist/cjs.js","mtime":1587098312615},{"path":"/Users/kimjunho/front/ssafyart_front/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1587098312803},{"path":"/Users/kimjunho/front/ssafyart_front/node_modules/postcss-loader/src/index.js","mtime":1579183907276},{"path":"/Users/kimjunho/front/ssafyart_front/node_modules/cache-loader/dist/cjs.js","mtime":1579183904604},{"path":"/Users/kimjunho/front/ssafyart_front/node_modules/vue-loader/lib/index.js","mtime":1587098312803}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgpib2R5IHsKICBwb3NpdGlvbjogZml4ZWQ7Cn0KLnBhaW50YWJsZSB7CiAgb3ZlcmZsb3c6IGhpZGRlbjsKICBwb3NpdGlvbjogZml4ZWQ7CiAgaGVpZ2h0OiAxMDAlOwogIHdpZHRoOiAxMDAlOwogIHRyYW5zZm9ybTogc2NhbGUoMSk7Cn0KLnBhaW50YWJsZS5hY3RpdmUgewogIHotaW5kZXg6IDA7Cn0KLnBhaW50YWJsZSAuY2FudmFzIHsKICBwb3NpdGlvbjogcmVsYXRpdmU7CiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7CiAgei1pbmRleDogLTE7CiAgcG9zaXRpb246IGFic29sdXRlOwogIGxlZnQ6IDA7CiAgdG9wOiAwOwogIG92ZXJmbG93OiBoaWRkZW47CiAgdG91Y2gtYWN0aW9uOiBub25lOwp9Ci5wYWludGFibGUgLmNhbnZhcy5hY3RpdmUgewogIHotaW5kZXg6IDEwMDA7Cn0KLnBhaW50YWJsZSAuY2FudmFzLmFjdGl2ZS5iYWNrIHsKICB6LWluZGV4OiA5OTk7Cn0K"},{"version":3,"sources":["Paintable.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Paintable.vue","sourceRoot":"src/components/components","sourcesContent":["<template>\n  <div class=\"paintable\" v-if=\"!hide\">\n    <Navigation\n      v-if=\"!disableNavigation\"\n      :horizontalNavigation=\"horizontalNavigation\"\n    >\n      <div slot=\"paintable-navigation-draw\"></div>\n    </Navigation>\n\n    <canvas\n      :ref=\"'canvas-' + canvasId\"\n      :class=\"{ active: isActive || alwaysOnTop }\"\n      :style=\"{\n        pointerEvents: !isActive ? 'none' : 'all',\n        display: !canvasIsEmpty || isActive ? 'block' : 'none'\n      }\"\n      class=\"canvas back\"\n      :width=\"width\"\n      :height=\"height\"\n    />\n\n    <canvas\n      :ref=\"'temp-canvas-' + canvasId\"\n      :class=\"{ active: isActive || alwaysOnTop }\"\n      :style=\"{\n        pointerEvents: !isActive ? 'none' : 'all',\n        display: !canvasIsEmpty || isActive ? 'block' : 'none'\n      }\"\n      class=\"canvas\"\n      :width=\"width\"\n      :height=\"height\"\n      @[drawMoveEvent]=\"drawMove\"\n      @[drawStartEvent]=\"drawStart\"\n      @[drawEndEvent]=\"drawEnd\"\n    />\n\n    <div class=\"content\">\n      <slot></slot>\n    </div>\n  </div>\n  <div v-else class=\"content\">\n    <slot></slot>\n  </div>\n</template>\n\n<script>\nlet currentX = 0;\nlet currentY = 0;\n\nimport Navigation from './Navigation';\n\nexport default {\n  name: 'paintable',\n  components: {\n    Navigation\n  },\n  props: {\n    factor: {\n      type: Number,\n      default: 1\n    },\n    navigation: {\n      type: Object,\n      default: null\n    },\n    alwaysOnTop: {\n      type: Boolean,\n      default: true\n    },\n    name: {\n      type: String,\n      required: true\n    },\n    width: {\n      type: Number,\n      default: window.innerWidth\n    },\n    height: {\n      type: Number,\n      default: window.innerHeight\n    },\n    hide: {\n      type: Boolean,\n      default: false\n    },\n    threshold: {\n      type: Number,\n      default: 0\n    },\n    showUndoRedo: {\n      type: Boolean,\n      default: true\n    },\n    showLineWidth: {\n      type: Boolean,\n      default: true\n    },\n    lineWidth: {\n      type: Number,\n      default: 5\n    },\n    lineWidthEraser: {\n      type: Number,\n      default: 20\n    },\n    colors: {\n      type: Array,\n      default: () => [\n        'black',\n        '#f00',\n        '#4481c7',\n        'rgba(255, 235, 59, 0.4)',\n        '#999',\n        'green'\n      ]\n    },\n    horizontalNavigation: {\n      type: Boolean,\n      default: false\n    },\n    disableNavigation: {\n      type: Boolean,\n      default: false\n    },\n    active: {\n      type: Boolean,\n      default: false\n    },\n    color: {\n      type: String,\n      default: '#000'\n    },\n    useEraser: {\n      type: Boolean,\n      default: false\n    }\n  },\n  data() {\n    return {\n      currentColor: this.color,\n      canvasIsEmpty: false,\n      canvasId: 0,\n      isEraserActive: this.useEraser,\n      isActive: this.active,\n      pointCoords: [],\n      redoList: [],\n      undoList: [],\n      currentLineWidth: this.isEraserActive\n        ? this.lineWidthEraser\n        : this.lineWidth,\n      tempCanvas: null,\n      tempCtx: null,\n      canvas: null,\n      ctx: null,\n      startedDrawing: false,\n      drawMoveEvent: 'mousemove',\n      drawStartEvent: 'mousedown',\n      drawEndEvent: 'mouseup',\n      isMouse: true,\n      thresholdReached: false\n    };\n  },\n  watch: {\n    isActive: 'init',\n    name: 'init',\n    hide() {\n      this.$nextTick(() => {\n        this.init();\n      });\n    },\n    lineWidth(lineWidth) {\n      this.currentLineWidth = lineWidth;\n    },\n    lineWidthEraser(lineWidth) {\n      this.currentLineWidth = lineWidth;\n    },\n    useEraser(useEraser) {\n      this.isEraserActive = useEraser;\n    },\n    active(isActive) {\n      this.isActive = isActive;\n    },\n    color(color) {\n      this.currentColor = color;\n      this.tempCtx.strokeStyle = this.currentColor;\n      this.ctx.strokeStyle = this.currentColor;\n    },\n    isEraserActive(isActive) {\n      this.currentLineWidth = isActive ? this.lineWidthEraser : this.lineWidth;\n    },\n    currentLineWidth(lineWidth) {\n      this.ctx.lineWidth = lineWidth;\n      this.tempCtx.lineWidth = lineWidth;\n    }\n  },\n  beforeMount() {\n    this.canvasId = Math.round(Math.random() * 1000);\n  },\n  created() {\n    if (this.isTouch) {\n      this.drawMoveEvent = 'touchmove';\n      this.drawStartEvent = 'touchstart';\n      this.drawEndEvent = 'touchend';\n      this.isMouse = false;\n    }\n  },\n  mounted() {\n    this.init();\n  },\n  computed: {\n    /**\n     * Get scaling factor of current device\n     */\n    scalingFactor() {\n      return window.devicePixelRatio || 1;\n    },\n    /**\n     * Check if it is a touch device\n     * thanks to: https://ctrlq.org/code/19616-detect-touch-screen-javascript\n     */\n    isTouch() {\n      return (\n        'ontouchstart' in window ||\n        navigator.MaxTouchPoints > 0 ||\n        navigator.msMaxTouchPoints > 0\n      );\n    }\n  },\n  methods: {\n    /**\n     * Cancel current drawing and remove lines\n     */\n    cancelDrawing() {\n      this.loadImageFromStorage();\n      this.isActive = false;\n      this.isColorPickerOpen = false;\n      this.isLineWidthPickerOpen = false;\n    },\n    /**\n     * Set storage item\n     * @param {string} key\n     * @param {string} value\n     */\n    setItem(key, value) {\n      localStorage.setItem(key, value);\n    },\n    /**\n     * Get storage item\n     * @param {string} key\n     */\n    async getItem(key) {\n      return localStorage.getItem(key);\n    },\n    /**\n     * Remove item from storage\n     * @param {string} key\n     */\n    removeItem(key) {\n      localStorage.removeItem(key);\n    },\n    /**\n     * Init paintable component and set all variables\n     */\n    init() {\n      try {\n        this.pointCoords = [];\n\n        // temporary canvas\n        this.tempCanvas = this.$refs['temp-canvas-' + this.canvasId];\n        this.tempCtx = this.tempCanvas.getContext('2d');\n\n        // canvas with drawing\n        this.canvas = this.$refs['canvas-' + this.canvasId];\n        this.ctx = this.canvas.getContext('2d');\n\n        this.tempCtx.lineCap = 'round';\n        this.ctx.lineCap = 'round';\n\n        this.tempCtx.lineWidth = this.lineWidth;\n        this.ctx.lineWidth = this.lineWidth;\n\n        this.tempCtx.strokeStyle = this.currentColor;\n        this.ctx.strokeStyle = this.currentColor;\n\n        this.setItem(\n          this.name + '-settings',\n          JSON.stringify({\n            width: this.canvas.width,\n            height: this.canvas.height\n          })\n        );\n\n        // set canvas width and height\n        this.setCanvasSize();\n\n        // load image from storage\n        this.loadImageFromStorage();\n\n        this.$emit('toggle-paintable', this.isActive);\n      } catch (err) {\n        // this.hide = true;\n        // this.hidePaintableNavigation = true;\n      }\n    },\n    //--------------------------------------------------\n    /**\n     * Undo drawed line\n     */\n    undoDrawingStep() {\n      this.restoreCanvasState(this.undoList, this.redoList);\n    },\n    /**\n     * Redo drawed line\n     */\n    redoDrawingStep() {\n      this.restoreCanvasState(this.redoList, this.undoList);\n    },\n    /**\n     * Restore previous image\n     */\n    restoreCanvasState(pop, push) {\n      this.ctx.globalCompositeOperation = 'source-over';\n      if (pop.length) {\n        const restore_state = pop.pop();\n        this.saveCurrentCanvasState(this.canvas, push, true);\n        this.loadImageFromStorage(restore_state);\n      }\n    },\n    /**\n     * Save the current canvas state an push it to undo- or redolist\n     */\n    saveCurrentCanvasState(canvas, list, keepRedo) {\n      keepRedo = keepRedo || false;\n      if (!keepRedo) {\n        this.redoList = [];\n      }\n\n      (list || this.undoList).push(canvas.toDataURL('image/png'));\n    },\n    //-------------------------------------------------------------------------\n    /**\n     * Get base64 from local storage and load it into canvas\n     */\n    async loadImageFromStorage(image) {\n      this.clearCanvas();\n\n      const base64Image = image || (await this.getItem(this.name));\n      if (base64Image) {\n        let image = new Image();\n        image.onload = () => {\n          this.ctx.drawImage(image, 0, 0);\n          this.canvasIsEmpty = this.isCanvasBlank();\n        };\n        image.src = base64Image; // eslint-disable-line\n      } else {\n        this.canvasIsEmpty = this.isCanvasBlank();\n      }\n    },\n    /**\n     * Set current canvas size\n     */\n    setCanvasSize() {\n      // this.width = window.innerWidth;\n      // this.height = window.innerHeight;\n      currentX = 0;\n      currentY = 0;\n    },\n    /**\n     * Clear complete canvas\n     */\n    clearCanvas() {\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    },\n    isCanvasBlank() {\n      this.ctx.globalCompositeOperation = 'source-over';\n\n      const blank = document.createElement('canvas');\n      const blankCtx = blank.getContext('2d');\n\n      blankCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n      blank.width = this.canvas.width;\n      blank.height = this.canvas.height;\n\n      return blank.toDataURL() === this.canvas.toDataURL();\n    },\n    /**\n     * Check first, if canvas is empty.\n     * If its not empty save it to the storage.\n     */\n    saveCurrentCanvasToStorage() {\n      // reset to pencil\n      this.isEraserActive = false;\n\n      if (this.isCanvasBlank()) {\n        this.removeItem(this.name);\n        this.removeItem(this.name + '-settings');\n      } else {\n        this.setItem(this.name, this.canvas.toDataURL('image/png'));\n        this.setItem(\n          this.name + '-settings',\n          JSON.stringify({\n            width: this.canvas.width,\n            height: this.canvas.height\n          })\n        );\n      }\n      this.undoList = [];\n      this.redoList = [];\n\n      this.canvasIsEmpty = this.isCanvasBlank();\n    },\n    //-------------------------------------------------------------------------\n    /**\n     * Start drawing lines\n     */\n    drawStart(e) {\n      e.preventDefault();\n      this.thresholdReached = false;\n      if (this.isActive) {\n        this.isLineWidthPickerOpen = false;\n        this.isColorPickerOpen = false;\n        this.startedDrawing = true;\n\n        this.saveCurrentCanvasState(this.canvas);\n\n        const x = !this.isMouse ? e.targetTouches[0].clientX : e.clientX;\n        const y = !this.isMouse ? e.targetTouches[0].clientY : e.clientY;\n\n        if (x && y) {\n          currentX =\n            x * this.factor - this.tempCanvas.getBoundingClientRect().left;\n          currentY =\n            y * this.factor - this.tempCanvas.getBoundingClientRect().top;\n\n          this.pointCoords.push({\n            x: currentX,\n            y: currentY\n          });\n        }\n\n        this.tempCtx.globalCompositeOperation = 'source-over';\n        this.ctx.globalCompositeOperation = this.isEraserActive\n          ? 'destination-out'\n          : 'source-over';\n      }\n    },\n    /**\n     * End of drawing a line\n     */\n    drawEnd() {\n      if (this.isActive) {\n        this.drawLine(this.ctx);\n        this.startedDrawing = false;\n\n        this.pointCoords = [];\n        this.thresholdReached = false;\n      }\n    },\n    /**\n     * Generate line from points array\n     */\n    drawLine(context) {\n      this.tempCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n      let p1 = this.pointCoords[0];\n      let p2 = this.pointCoords[1];\n\n      if (p1 && p2 && p1.x && p1.y) {\n        context.beginPath();\n        context.moveTo(p1.x, p1.y);\n\n        for (let i = 1, len = this.pointCoords.length; i < len; i++) {\n          let midPoint = {\n            x: p1.x + (p2.x - p1.x) / 2,\n            y: p1.y + (p2.y - p1.y) / 2\n          };\n          context.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\n          p1 = this.pointCoords[i];\n          p2 = this.pointCoords[i + 1];\n        }\n\n        context.lineTo(p1.x, p1.y);\n        context.stroke();\n        context.closePath();\n      }\n    },\n    /**\n     * Draw line on move and add current position to an array\n     */\n    drawMove(e) {\n      e.preventDefault();\n\n      if (this.isActive && this.startedDrawing) {\n        const x = !this.isMouse ? e.targetTouches[0].clientX : e.clientX;\n        const y = !this.isMouse ? e.targetTouches[0].clientY : e.clientY;\n\n        if (x && y) {\n          currentX =\n            x * this.factor - this.tempCanvas.getBoundingClientRect().left;\n          currentY =\n            y * this.factor - this.tempCanvas.getBoundingClientRect().top;\n\n          this.pointCoords.push({\n            x: currentX,\n            y: currentY\n          });\n\n          if (this.threshold) {\n            const distanceFirstAndLastPoint = Math.sqrt(\n              Math.pow(\n                this.pointCoords[this.pointCoords.length - 1].y -\n                  this.pointCoords[0].y,\n                2\n              ) +\n                Math.pow(\n                  this.pointCoords[this.pointCoords.length - 1].x -\n                    this.pointCoords[0].x,\n                  2\n                )\n            );\n\n            if (distanceFirstAndLastPoint > this.threshold) {\n              if (!this.thresholdReached) {\n                this.thresholdReached = true;\n                this.$emit('thresholdReached');\n              }\n            }\n          }\n\n          this.drawLine(!this.isEraserActive ? this.tempCtx : this.ctx);\n        }\n      }\n    }\n  }\n};\n</script>\n\n<style scoped>\nbody {\n  position: fixed;\n}\n.paintable {\n  overflow: hidden;\n  position: fixed;\n  height: 100%;\n  width: 100%;\n  transform: scale(1);\n}\n.paintable.active {\n  z-index: 0;\n}\n.paintable .canvas {\n  position: relative;\n  background-color: transparent;\n  z-index: -1;\n  position: absolute;\n  left: 0;\n  top: 0;\n  overflow: hidden;\n  touch-action: none;\n}\n.paintable .canvas.active {\n  z-index: 1000;\n}\n.paintable .canvas.active.back {\n  z-index: 999;\n}\n</style>\n"]}]}